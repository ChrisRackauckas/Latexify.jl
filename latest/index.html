<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Latexify.jl · Latexify.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Latexify.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Latexify.jl</a><ul class="internal"><li><a class="toctext" href="#At-a-glance-1">At a glance</a></li><li><a class="toctext" href="#latexalign(x)-1"><code>latexalign(x)</code></a></li><li><a class="toctext" href="#Inner-workings-1">Inner workings</a></li><li><a class="toctext" href="#Extended-functionality-1">Extended functionality</a></li><li><a class="toctext" href="#Latexifying-Arrays-1">Latexifying Arrays</a></li></ul></li><li><span class="toctext">Demos</span><ul><li><a class="toctext" href="tutorials/latexify.html">latexify</a></li><li><a class="toctext" href="tutorials/latexarray.html">latexarray</a></li></ul></li><li><span class="toctext">Functions</span><ul><li><a class="toctext" href="functions/latexify.html">latexify</a></li><li><a class="toctext" href="functions/latexalign.html">latexalign</a></li><li><a class="toctext" href="functions/latexarray.html">latexarray</a></li><li><a class="toctext" href="functions/latexoperation.html">latexoperation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Latexify.jl</a></li></ul><a class="edit-page" href="https://github.com/korsbo/Latexify.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Latexify.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Latexify.jl-1" href="#Latexify.jl-1">Latexify.jl</a></h1><p>Latexify.jl is a package which supplies functions for producing <span>$\LaTeX$</span> formatted strings from Julia objects.</p><p>This package allows, among other things, for converting a Julia expression to a <span>$\LaTeX$</span> formatted equation.</p><h2><a class="nav-anchor" id="At-a-glance-1" href="#At-a-glance-1">At a glance</a></h2><p>This package provides a few functions of potential interest:</p><h3><a class="nav-anchor" id="latexify(x)-1" href="#latexify(x)-1"><code>latexify(x)</code></a></h3><p>takes a Julia object <code>x</code> and returns a <span>$\LaTeX$</span> formatted string. This works for <code>x</code> of many types, including expressions, which returns <span>$\LaTeX$</span> code for an equation.</p><pre><code class="language-julia">julia&gt; ex = :(x-y/z)
julia&gt; latexify(ex)
&quot;x - \\frac{y}{z}&quot;</code></pre><p>Among the supported types are:</p><ul><li><p>Expressions,</p></li><li><p>Strings,</p></li><li><p>Numbers (including rational and complex),</p></li><li><p>Symbols,</p></li><li><p>Symbolic expressions from SymEngine.jl.</p></li></ul><p>It can also take arrays, which it recurses and latexifies the elements, returning an array of latex strings.</p><h2><a class="nav-anchor" id="latexalign(x)-1" href="#latexalign(x)-1"><code>latexalign(x)</code></a></h2><p>While <code>latexify</code> does not provide a <span>$\LaTeX$</span> environment surrounding the resulting string, <code>latexalign</code> does. As the name implies, it creates an <code>align</code> environment.</p><pre><code class="language-julia">lhs = [&quot;dx/dt&quot;, &quot;dy/dt&quot;]
rhs = [&quot;y^2 - x&quot;, &quot;x/y - y&quot;]
print(latexalign(lhs, rhs))</code></pre><p>outputs:</p><pre><code class="language-maths">\begin{align}
\frac{dx}{dt} =&amp; y^{2} - x \\
\frac{dy}{dt} =&amp; \frac{x}{y} - y \\
\end{align}</code></pre><p>In Jupyter, this can be rendered by:</p><pre><code class="language-julia">display(&quot;text/latex&quot;, latexalign(lhs, rhs))</code></pre><p>\begin{align*} \frac{dx}{dt} =&amp; y^{2} - x \\
\frac{dy}{dt} =&amp; \frac{x}{y} - y \\
\end{align*}</p><h4><a class="nav-anchor" id="Using-DifferentialEquations.jl-1" href="#Using-DifferentialEquations.jl-1">Using DifferentialEquations.jl</a></h4><p>The motivation for creating this function was mainly to be able to render ODEs. In my own work, I tend to use <a href="http://docs.juliadiffeq.org/stable/index.html">DifferentialEquations.jl</a> to define ODEs as <a href="http://docs.juliadiffeq.org/stable/analysis/parameterized_functions.html#Function-Definition-Macros-1">ParameterizedFunctions</a>. Therefore, I found it useful to create a method which simply takes the ParameterizedFunction as input:</p><pre><code class="language-julia">using DifferentialEquations
ode = @ode_def positiveFeedback begin
    dx = y/(k_y + y) - x
    dy = x^n_x/(k_x^n_x + x^n_x) - y
end k_y=&gt;1.0 k_x=&gt;1.0 n_x=&gt;1

print(latexalign(ode))</code></pre><p>This generates <span>$\LaTeX$</span> code that renders as:</p><p>\begin{align} \frac{dx}{dt} =&amp; \frac{y}{k_{y} + y} - x \\
\frac{dy}{dt} =&amp; \frac{x^{n_{x}}}{k_{x}^{n_{x}} + x^{n_{x}}} - y \\
\end{align}</p><h2><a class="nav-anchor" id="Inner-workings-1" href="#Inner-workings-1">Inner workings</a></h2><p>This package contains a large number of methods, but two of these are of special importance. These are:</p><ul><li><p><code>latexify(ex::Expr)</code></p></li></ul><p>and</p><ul><li><p><code>latexoperation(ex::Expr, prevOp::AbstractArray)</code></p></li></ul><p>Almost all other functions or methods eventually lead to these two.</p><p><code>latexify(ex::Expr)</code> utilises Julias homoiconicity to infer the correct latexification of an expression by recursing through the expression tree. Whenever it hits the end of a recursion it passes the last expression to <code>latexoperation()</code>. By the nature of this recursion, this expression is one which only contains symbols or strings.</p><h3><a class="nav-anchor" id="Explanation-by-example-1" href="#Explanation-by-example-1">Explanation by example</a></h3><p>Let&#39;s define a variable of the expression type:</p><pre><code class="language-julia-repl">julia&gt; ex = :(x + y/z)</code></pre><p>This expression has a field which contains the first operation which must be done, along with the objects that this operation will operate on:</p><pre><code class="language-julia-repl">julia&gt; ex.args

3-element Array{Any,1}:
 :+      
 :x      
 :(y / z)</code></pre><p>The first two element are both Symbols, while the third one is an expression:</p><pre><code class="language-julia-repl">julia&gt; typeof.(ex.args)

3-element Array{DataType,1}:
 Symbol
 Symbol
 Expr</code></pre><p>Since at least one of these elements is an expression, the next step of the recursive algorithm is to dive into that expression:</p><pre><code class="language-julia-repl">julia&gt; newEX = ex.args[3]
julia&gt; newEx.args

3-element Array{Any,1}:
 :/
 :y
 :z</code></pre><p>Since none of these arguments is another expression, <code>newEx</code> will be passed to <code>latexoperation()</code>. This function checks which mathematical operation is being done and converts newEx to an appropriately formatted string. In this case, that string will be &quot;\\frac{y}{z}&quot; (and yes, a double slash is needed).</p><p><code>newEx</code> is now a string (despite its name):</p><pre><code class="language-julia">julia&gt; newEx

&quot;\\frac{y}{z}&quot;</code></pre><p>The recursive <code>latexify()</code> pulls this value back to the original expression <code>ex</code>, such that:</p><pre><code class="language-julia-repl">julia&gt; ex.args

3-element Array{Any,1}:
 :+      
 :x      
 :&quot;\\frac{y}{z}&quot;</code></pre><p>Now, since this expression does not consist of any further expressions, it is passed to <code>latexoperation()</code>. The operator is now &quot;+&quot;, and it should be applied on the second and third element of the expression, resulting in:</p><pre><code class="language-julia">&quot;x + \\frac{y}{z}&quot;</code></pre><p>using the print function you get:</p><pre><code class="language-julia-repl">julia&gt; print(latexify(ex))

&quot;x + \frac{y}{z}&quot;</code></pre><p>which in a <span>$\LaTeX$</span> maths environment renders as:</p><div>\[x + \frac{y}{z}\]</div><h2><a class="nav-anchor" id="Extended-functionality-1" href="#Extended-functionality-1">Extended functionality</a></h2><p>With the above example we can understand how an expression is converted to a <span>$\LaTeX$</span> formatted string (unless my pedagogical skills are worse than I fear).</p><p>So, anything which can be converted to a Julia expression of the Expr type can be latexified. Luckily, since Julia needs to convert your code to expressions before it can be evaluated, Julia is already great at doing this.</p><p>There are already some methods for converting other types to expressions and passing them to the core method, for example:</p><pre><code class="language-julia">latexify(str::String) = latexify(parse(str))</code></pre><p>but if you find yourself wanting to parse some other type, it is often easy to overload the <code>latexify</code> function.</p><h2><a class="nav-anchor" id="Latexifying-Arrays-1" href="#Latexifying-Arrays-1">Latexifying Arrays</a></h2><p>Also, if you pass an array to <code>latexify</code>, it will recursively try to convert the elements of that array to <span>$\LaTeX$</span> formatted strings.</p><pre><code class="language-julia-repl">julia&gt; arr = [:(x-y/(k_10+z)), &quot;x*y*z/3&quot;]
julia&gt; latexify(arr)
2-element Array{String,1}:
 &quot;x - \\frac{y}{k_{10} + z}&quot;     
 &quot;\\frac{x \\cdot y \\cdot z}{3}&quot;

julia&gt; println.(latexify(arr))
x - \frac{y}{k_{10} + z}
\frac{x \cdot y \cdot z}{3}</code></pre><footer><hr/><a class="next" href="tutorials/latexify.html"><span class="direction">Next</span><span class="title">latexify</span></a></footer></article></body></html>
